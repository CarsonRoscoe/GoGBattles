"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefenderRelaySenderProvider = void 0;
const lodash_1 = require("lodash");
const util_1 = require("util");
const relayer_1 = require("../relayer");
class DefenderRelaySenderProvider {
    constructor(base, relayerCredentials, options = {}) {
        this.base = base;
        this.options = options;
        this.id = 1;
        this.txHashToId = new Map();
        this._delegateToProvider(base);
        this.relayer = relayer_1.isRelayer(relayerCredentials) ? relayerCredentials : new relayer_1.Relayer(relayerCredentials);
    }
    get connected() {
        return this.base.connected;
    }
    getTransactionId(hash) {
        return this.txHashToId.get(hash);
    }
    async getAddress() {
        if (!this.address) {
            const address = await this.relayer.getRelayer().then((r) => r.address);
            this.address = address;
        }
        return this.address;
    }
    sendAsync(payload, callback) {
        return this.send(payload, callback);
    }
    send(payload, callback) {
        var _a, _b;
        const id = typeof payload.id === 'string' ? parseInt(payload.id) : (_a = payload.id) !== null && _a !== void 0 ? _a : this.id++;
        const handleWith = (fn) => util_1.callbackify((payload) => fn.call(this, payload.params).then((result) => ({
            jsonrpc: '2.0',
            id,
            result,
        })))(payload, callback);
        switch (payload.method) {
            case 'eth_sendTransaction':
                return handleWith(this._sendTransaction);
            case 'eth_accounts':
                return handleWith(this._getAccounts);
            case 'eth_sign':
                return handleWith(this._signMessage);
            case 'eth_signTransaction':
                return callback(new Error(`Method not supported: eth_signTransaction`));
        }
        // Default by sending to base provider
        return ((_b = this.base.sendAsync) !== null && _b !== void 0 ? _b : this.base.send).call(this.base, payload, callback);
    }
    async _getAccounts(params) {
        return [await this.getAddress()];
    }
    async _sendTransaction(params) {
        var _a;
        const tx = params[0];
        const relayerAddress = (await this.getAddress()).toLowerCase();
        if (tx.from && tx.from.toLowerCase() !== relayerAddress) {
            throw new Error(`Cannot send transaction from ${tx.from}`);
        }
        const gasLimit = (_a = tx.gas) !== null && _a !== void 0 ? _a : (await util_1.promisify(this.send.bind(this))({
            method: 'eth_estimateGas',
            params: [{ from: relayerAddress, gasLimit: 1e6, ...tx }],
            jsonrpc: '2.0',
            id: 1,
        }).then((response) => {
            var _a;
            if (response === null || response === void 0 ? void 0 : response.error) {
                throw new Error(`Error estimating gas for transaction: ${JSON.stringify(response.error)}`);
            }
            return (_a = response === null || response === void 0 ? void 0 : response.result) === null || _a === void 0 ? void 0 : _a.toString();
        }));
        const txWithSpeed = this.options.speed ? { ...lodash_1.omit(tx, 'gasPrice'), speed: this.options.speed } : tx;
        const payload = { ...this.options, ...txWithSpeed, gasLimit };
        const sent = tx.nonce
            ? await this.relayer.replaceTransactionByNonce(parseInt(tx.nonce), payload)
            : await this.relayer.sendTransaction(payload);
        this.txHashToId.set(sent.hash, sent.transactionId);
        return sent.hash;
    }
    async _signMessage(params) {
        const [from, message] = params;
        if (from.toLowerCase() !== (await this.getAddress()).toLowerCase()) {
            throw new Error(`Cannot sign message as ${from}`);
        }
        return this.relayer.sign({ message }).then((r) => r.sig);
    }
    _delegateToProvider(provider) {
        // Sorry for all the anys
        const delegate = (fn) => {
            if (typeof provider[fn] === 'function') {
                this[fn] = provider[fn].bind(provider);
            }
        };
        // If the subprovider is a ws or ipc provider, then register all its methods on this provider
        // and delegate calls to the subprovider. This allows subscriptions to work.
        delegate('eventNames');
        delegate('listeners');
        delegate('listenerCount');
        delegate('emit');
        delegate('on');
        delegate('addListener');
        delegate('once');
        delegate('removeListener');
        delegate('off');
        delegate('removeAllListeners');
        delegate('connect');
        delegate('reset');
        delegate('disconnect');
        delegate('supportsSubscriptions');
        delegate('reconnect');
    }
}
exports.DefenderRelaySenderProvider = DefenderRelaySenderProvider;
