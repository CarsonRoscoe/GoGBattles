"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefenderRelaySigner = void 0;
const strings_1 = require("@ethersproject/strings");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const bytes_1 = require("@ethersproject/bytes");
const bignumber_1 = require("@ethersproject/bignumber");
const logger_1 = require("@ethersproject/logger");
const properties_1 = require("@ethersproject/properties");
const relayer_1 = require("../relayer");
const logger = new logger_1.Logger(`defender-relay-client`);
const allowedTransactionKeys = [
    'chainId',
    'data',
    'from',
    'gasLimit',
    'gasPrice',
    'nonce',
    'to',
    'value',
    'speed',
];
class DefenderRelaySigner extends abstract_signer_1.Signer {
    constructor(relayerCredentials, provider, options = {}) {
        super();
        this.relayerCredentials = relayerCredentials;
        this.provider = provider;
        this.options = options;
        this.relayer = relayer_1.isRelayer(relayerCredentials) ? relayerCredentials : new relayer_1.Relayer(relayerCredentials);
        if (options && options.speed && options.gasPrice) {
            throw new Error(`Cannot set both speed and fixed gasPrice`);
        }
    }
    async getAddress() {
        // cache value because it does not change
        if (!this.address) {
            const r = await this.relayer.getRelayer();
            this.address = r.address;
        }
        return this.address;
    }
    // Returns the signed prefixed-message. This MUST treat:
    // - Bytes as a binary message
    // - string as a UTF8-message
    // i.e. "0x1234" is a SIX (6) byte string, NOT 2 bytes of data
    async signMessage(message) {
        if (typeof message === 'string') {
            message = strings_1.toUtf8Bytes(message);
        }
        const sig = await this.relayer.sign({
            message: bytes_1.hexlify(message),
        });
        return bytes_1.joinSignature(sig);
    }
    // Signs a transaxction and returns the fully serialized, signed transaction.
    // The EXACT transaction MUST be signed, and NO additional properties to be added.
    // - This MAY throw if signing transactions is not supports, but if
    //   it does, sentTransaction MUST be overridden.
    async signTransaction(transaction) {
        throw new Error('DefenderRelaySigner#signTransaction: method not yet supported');
    }
    connect(provider) {
        return new DefenderRelaySigner(this.relayerCredentials, provider, this.options);
    }
    async sendTransaction(transaction) {
        var _a, _b;
        this._checkProvider('sendTransaction');
        const tx = await this.populateTransaction(transaction);
        if (!tx.gasLimit)
            throw new Error('DefenderRelaySigner#sendTransacton: relayer gas estimation not yet supported');
        const nonce = tx.nonce === undefined ? undefined : bignumber_1.BigNumber.from(tx.nonce).toNumber();
        const payload = {
            to: tx.to,
            gasLimit: bytes_1.hexlify(tx.gasLimit),
            data: tx.data ? bytes_1.hexlify(tx.data) : undefined,
            speed: tx.speed,
            gasPrice: tx.gasPrice ? bytes_1.hexlify(tx.gasPrice) : undefined,
            value: tx.value ? bytes_1.hexlify(tx.value) : undefined,
            validUntil: tx.validUntil ? new Date(tx.validUntil).toISOString() : undefined,
        };
        const relayedTransaction = nonce
            ? await this.relayer.replaceTransactionByNonce(nonce, payload)
            : await this.relayer.sendTransaction(payload);
        return this.provider._wrapTransaction({
            ...relayedTransaction,
            gasLimit: bignumber_1.BigNumber.from(relayedTransaction.gasLimit),
            gasPrice: bignumber_1.BigNumber.from(relayedTransaction.gasPrice),
            value: bignumber_1.BigNumber.from((_a = relayedTransaction.value) !== null && _a !== void 0 ? _a : 0),
            data: (_b = relayedTransaction.data) !== null && _b !== void 0 ? _b : '',
        }, relayedTransaction.hash);
    }
    // Adapted from ethers-io/ethers.js/packages/abstract-signer/src.ts/index.ts
    // Defender relay does not require all fields to be populated
    async populateTransaction(transaction) {
        const tx = await properties_1.resolveProperties(this.checkTransaction(transaction));
        if (tx.to != null) {
            tx.to = Promise.resolve(tx.to).then((to) => this.resolveName(to));
        }
        if (tx.gasLimit == null) {
            tx.gasLimit = this.estimateGas(tx).catch((error) => {
                return logger.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: error,
                    tx: tx,
                });
            });
        }
        if (!tx.speed && !tx.gasPrice) {
            if (this.options.gasPrice) {
                tx.gasPrice = this.options.gasPrice;
            }
            else if (this.options.speed) {
                tx.speed = this.options.speed;
            }
        }
        if (!tx.validUntil && this.options.validForSeconds) {
            tx.validUntil = new Date(Date.now() + this.options.validForSeconds * 1000);
        }
        return await properties_1.resolveProperties(tx);
    }
    // Adapted from ethers-io/ethers.js/packages/abstract-signer/src.ts/index.ts
    // Defender relay accepts more transaction keys
    checkTransaction(transaction) {
        for (const key in transaction) {
            if (allowedTransactionKeys.indexOf(key) === -1) {
                logger.throwArgumentError('invalid transaction key: ' + key, 'transaction', transaction);
            }
        }
        const tx = properties_1.shallowCopy(transaction);
        tx.from = Promise.all([Promise.resolve(tx.from), this.getAddress()]).then((result) => {
            if (!!result[0] && result[0].toLowerCase() !== result[1].toLowerCase()) {
                logger.throwArgumentError('from address mismatch', 'transaction', transaction);
            }
            return result[1];
        });
        return tx;
    }
}
exports.DefenderRelaySigner = DefenderRelaySigner;
