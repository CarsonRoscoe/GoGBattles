"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefenderRelayProvider = void 0;
const providers_1 = require("@ethersproject/providers");
const relayer_1 = require("../relayer");
const signer_1 = require("./signer");
const properties_1 = require("@ethersproject/properties");
const bignumber_1 = require("@ethersproject/bignumber");
const api_1 = require("../api");
class DefenderRelayProvider extends providers_1.StaticJsonRpcProvider {
    constructor(credentials) {
        super(api_1.RelayerApiUrl());
        this.credentials = credentials;
        this.relayer = new relayer_1.Relayer(credentials);
    }
    async detectNetwork() {
        if (this.network != null) {
            return this.network;
        }
        // Logic from JsonRpcProvider.detectNetwork
        let chainId = null;
        try {
            chainId = await this.send('eth_chainId', []);
        }
        catch (error) {
            try {
                chainId = await this.send('net_version', []);
            }
            catch (error) {
                // Key difference from JsonRpcProvider.detectNetwork logic
                // This surfaces error to caller (like QuotaExceeded) instead of squashing it
                throw error;
            }
        }
        if (chainId === null) {
            throw new Error('could not detect chainId');
        }
        // Logic from JsonRpcProvider.detectNetwork
        const getNetwork = properties_1.getStatic(this.constructor, 'getNetwork');
        const network = getNetwork(bignumber_1.BigNumber.from(chainId).toNumber());
        if (!network) {
            throw new Error('could not detect network');
        }
        // Logic from StaticJsonRpcProvider.detectNetwork
        if (this._network == null) {
            properties_1.defineReadOnly(this, '_network', network);
            this.emit('network', network, null);
        }
        return network;
    }
    async send(method, params) {
        const request = { method, params };
        this.emit('debug', { action: 'request', request, provider: this });
        try {
            const result = await this.relayer.call(method, params);
            this.emit('debug', { action: 'response', request, response: result, provider: this });
            if (result.error) {
                const error = new Error(result.error.message);
                error.code = result.error.code;
                error.data = result.error.data;
                throw error;
            }
            return result.result;
        }
        catch (error) {
            this.emit('debug', { action: 'response', error, request: request, provider: this });
            throw error;
        }
    }
    getSigner() {
        return new signer_1.DefenderRelaySigner(this.relayer, this, {});
    }
}
exports.DefenderRelayProvider = DefenderRelayProvider;
